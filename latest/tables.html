<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CasaCore.Tables · CasaCore.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="CasaCore.jl logo"/></a><h1>CasaCore.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><span class="toctext">Modules</span><ul><li class="current"><a class="toctext" href="tables.html">CasaCore.Tables</a><ul class="internal"><li><a class="toctext" href="#Columns-1">Columns</a></li><li><a class="toctext" href="#Cells-1">Cells</a></li><li><a class="toctext" href="#Keywords-1">Keywords</a></li><li><a class="toctext" href="#Subtables-1">Subtables</a></li><li><a class="toctext" href="#Best-Practices-1">Best Practices</a></li></ul></li><li><a class="toctext" href="measures.html">CasaCore.Measures</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href="tables.html">CasaCore.Tables</a></li></ul><a class="edit-page" href="https://github.com/mweastwood/CasaCore.jl/tree/acf2c4d826347f67aa8df05976b5066d0dc9518c/docs/src/tables.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>CasaCore.Tables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CasaCore.Tables-1" href="#CasaCore.Tables-1">CasaCore.Tables</a></h1><p>Load this module by running</p><pre><code class="language-julia">using CasaCore.Tables</code></pre><p>The <code>Tables</code> module is used to interact with CasaCore tables. This is a common data format in radio astronomy. For example CASA measurement sets and CASA calibration tables are simply CasaCore tables with a standard set of columns, keywords, and subtables.</p><p>Opening a table is simple:</p><pre><code class="language-julia">table = Table(&quot;/path/to/table&quot;)</code></pre><p>This will open an existing table at the given path, or create a new table if one does not already exist at that path. Note that a read/write lock is automatically obtained on an open table. This lock will automatically be released when the <code>table</code> object is garbage collected, but you may manually release the lock by calling <code>Tables.unlock(table)</code>.</p><h2><a class="nav-anchor" id="Columns-1" href="#Columns-1">Columns</a></h2><p>Columns are accessed by name. For example to read the entire <code>DATA</code> column from a measurement set:</p><pre><code class="language-julia">table = Table(&quot;/path/to/measurementset.ms&quot;)
data = table[&quot;DATA&quot;]</code></pre><p>If we have some function <code>calibrate</code> that solves for and applies a calibration to the measured visibilities, we can then write the calibrated data back to the <code>CORRECTED_DATA</code> column as follows:</p><pre><code class="language-julia">corrected_data = calibrate(data) # calibrate the measured visibilities
table[&quot;CORRECTED_DATA&quot;] = corrected_data</code></pre><p>Note that the <code>CORRECTED_DATA</code> column will be created in the table if it does not already exist. If the column does already exist, the column will be overwritten with the contents of <code>corrected_data</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>CasaCore.jl will throw a <code>CasaCoreError</code> exception if you try to overwrite a column with an array of the incorrect size or element type. A column that contains <code>float</code>s cannot be overwritten with an array of <code>int</code>s.</p></div></div><p>A column can be removed from the table by using <code>Tables.removecolumn!(table, &quot;name&quot;)</code>, where <code>&quot;name&quot;</code> is the name of the column to be removed from the table.</p><h2><a class="nav-anchor" id="Cells-1" href="#Cells-1">Cells</a></h2><p>If you do not want to read or write to an entire column, you can instead pick a single row of the column (ie. a cell). For example, the length of the 123rd baseline in a measurement set can be computed by:</p><pre><code class="language-julia">uvw = table[&quot;UVW&quot;, 123]
baseline_length = norm(uvw)</code></pre><p>If we then perform a calculation that updates the <code>uvw</code> coordinates of this baseline, we can write these changes back to the table:</p><pre><code class="language-julia">table[&quot;UVW&quot;, 123] = uvw</code></pre><p>The number of rows in the table can be obtained with <code>Tables.numrows(table)</code>.  Note also that the indexing order is column first, row second. This is opposite from the usual matrix convention where the first index specifies the row.</p><div class="admonition important"><div class="admonition-title">Important</div><div class="admonition-text"><p>Julia is 1-indexed programming language. This means that the first element of an array <code>x</code> is accessed with <code>x[1]</code> instead of <code>x[0]</code> (as is the case for C and Python). Similarly, the first row of a table is row number 1. Attempting to access row number 0 will throw a <code>CasaCoreError</code> because this row does not exist.</p></div></div><h2><a class="nav-anchor" id="Keywords-1" href="#Keywords-1">Keywords</a></h2><p>Keywords are accessed using the <code>kw&quot;...&quot;</code> string macro. For example:</p><pre><code class="language-julia">ms_version = table[kw&quot;MS_VERSION&quot;] # read the value of the &quot;MS_VERSION&quot; keyword
table[kw&quot;MS_VERSION&quot;] = 2.0        # set the value of the &quot;MS_VERSION&quot; keyword</code></pre><p>A keyword can be removed with the <code>Tables.removekeyword!</code> function.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>A current known limitation of CasaCore.jl is the inability to read from or write to keywords that contain an array of values. This will be fixed if you file a bug report!</p></div></div><h2><a class="nav-anchor" id="Subtables-1" href="#Subtables-1">Subtables</a></h2><p>Subtables can be opened by reading their location from the appropriate keyword, and opening them as you would a regular table.</p><pre><code class="language-julia">location = table[kw&quot;SPECTRAL_WINDOW&quot;]
subtable = Table(location)</code></pre><p>In this example the <code>SPECTRAL_WINDOW</code> keyword contains the path to the corresponding subtable, which usually contains information about the frequency bands and channels of a measurement set.</p><h2><a class="nav-anchor" id="Best-Practices-1" href="#Best-Practices-1">Best Practices</a></h2><h3><a class="nav-anchor" id="Type-Stability-1" href="#Type-Stability-1">Type Stability</a></h3><p>Julia is a dynamically typed language. Because of this we can write statements like <code>column = table[&quot;column&quot;]</code> without knowing the type of the column ahead of time. If the column contains <code>float</code>s (<code>Float32</code>), Julia will do the right thing. If the column contains <code>double</code>s (<code>Float64</code>), Julia will do the right thing. As a user, we did not need to know whether this column contains <code>float</code>s or <code>double</code>s ahead of time.</p><p>However Julia also performs &quot;type-inference&quot;. This means that Julia will attempt to deduce the types of your variables. If the types of your variables can be inferred at <em>compile time</em>, Julia will generate more efficient machine code specialized on the types that it inferred. If the types of your variables cannot be inferred at <em>compile time</em>, Julia will need to generate less efficient generic code to account for the uncertainty in the types of your variables.</p><p>This concept is important for <code>CasaCore.Tables</code> because the result of <code>table[&quot;column&quot;]</code> can be a wide variety of different types, and the actual type isn&#39;t known until <em>run time</em>. Now consider the following example:</p><pre><code class="language-julia">function add_one_to_data_column(table)
    column = table[&quot;DATA&quot;] # type of `column` cannot be inferred
    for idx in eachindex(column)
        column[idx] += 1
    end
    table[&quot;DATA&quot;] = column
end</code></pre><p>This function will read the <code>DATA</code> column from the given table, add one to each element, and then write the result back to the table. However because the type of <code>column</code> cannot be inferred, the performance of the <code>for</code>-loop will be sub-optimal. We can remedy this problem by moving the computational kernel into a separate function:</p><pre><code class="language-julia">function add_one_to_data_column(table)
    column = table[&quot;DATA&quot;]
    do_the_for_loop(column) # `do_the_for_loop` specializes on the actual type of `column`
    table[&quot;DATA&quot;] = column
end

function do_the_for_loop(column)
    for idx in eachindex(column)
        column[idx] += 1
    end
end</code></pre><p>When <code>do_the_for_loop</code> is called, Julia will specialize the function on the actual type of <code>column</code>. That is, the <code>for</code>-loop will be compiled with the knowledge of the actual type of <code>column</code>.  This specialization ultimately means that the latter example will generally be faster.</p><p>For more information please refer to the <a href="http://docs.julialang.org/en/release-0.5/manual/performance-tips/#separate-kernel-functions-aka-function-barriers">performance tips section</a> of the Julia manual.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="measures.html"><span class="direction">Next</span><span class="title">CasaCore.Measures</span></a></footer></article></body></html>
